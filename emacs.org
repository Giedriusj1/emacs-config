#+TITLE: Emacs config

* INIT BASICS                                                 :config:basics:
#+begin_src emacs-lisp
(message "emacs.org : starting init stage")
#+end_src
** repo load
#+begin_src emacs-lisp
(require 'package)
(require 'cl)

(add-to-list 'load-path "~/.emacs.d/elpa")
(setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
			 ("malade" . "http://marmalade-repo.org/packages/")
			 ("melpa" . "http://melpa.milkbox.net/packages/")))

(package-initialize)

;;(byte-recompile-directory (expand-file-name "~/.emacs.d/elpa") 0)
(setq url-http-attempt-keepalives nil)

(defvar package-list
  '(avy
    yasnippet
    igrep
    google-this
    zygospore
    bookmark+
    helm-descbinds
    monokai-theme
    auto-highlight-symbol
    helm-projectile
    dired-toggle-sudo
    multi-term
    iasm-mode
    matlab-mode
    haskell-mode
    magit
    highline
    lua-mode
    smooth-scrolling
    elpy
    auctex
    emacs-eclim
    auto-install
    auto-complete-clang
    helm
    helm-swoop
    bind-key
    projectile
    auto-complete-c-headers
    powerline
    icomplete+
    dired+
    dired-ranger
    auto-complete
    ac-dabbrev
    isearch+
    smooth-scroll
    flymake-haskell-multi
    all-ext
    hydra
    swiper
    swiper-helm)
)

(defun packages-installed ()
  (loop for p in package-list
        when (not (package-installed-p p)) do (return nil)
        finally (return t)))

(unless (packages-installed)
  (package-refresh-contents)

  (dolist (p package-list)
    (when (not (package-installed-p p))
      (package-install p))))

#+end_src
** customize-set
#+BEGIN_SRC emacs-lisp
(customize-set-variable 'scroll-bar-mode nil)
(customize-set-variable 'horizontal-scroll-bar-mode nil)
(customize-set-variable 'menu-bar-mode nil)
(customize-set-variable 'tool-bar-mode nil)

(cond
 ((string-equal system-type "windows-nt")
  (set-frame-font "Consolas-10"))
 ((string-equal system-type "darwin")
  (message "what?"))
 ((string-equal system-type "gnu/linux")
  (set-frame-font "Monospace-10")))

(custom-set-variables '(custom-enabled-themes (quote (wombat))) )
;;(load-theme 'monokai t)

(customize-set-variable 'fci-rule-color "#BBBBBB")
(customize-set-variable 'electric-pair-mode t)
(customize-set-variable 'directory-free-space-args "-Pkh")

(customize-set-variable 'bmkp-last-as-first-bookmark-file "~/.emacs.d/bookmarks" )

(custom-set-faces '(highline-face ((t (:background "#303030")))))
#+END_SRC

** Keyboard
*** maps
#+begin_src emacs-lisp
(define-prefix-command 'alt-semi-map)
(define-prefix-command 'control-semi-map)
(define-prefix-command 'tab-map)
(define-prefix-command 'ret-map)
(define-prefix-command 'hyper-semi-map)
(define-prefix-command 'meta-semi-map)
(define-prefix-command 'tab-org-map)

(require 'bind-key)
(bind-key* "C-;" 'control-semi-map)
(bind-key* "H-;" 'hyper-semi-map)
(bind-key* "M-;" 'meta-semi-map)
(bind-key* "<tab>" 'tab-map)

(define-key tab-map (kbd "o") 'tab-org-map)
#+end_src

*** global map
#+begin_src emacs-lisp
(global-set-key [f11] 'toggle-truncate-lines)
(global-set-key [f12] 'whitespace-mode)

(global-set-key (kbd "C-<f11>") 'toggle-frame-fullscreen)

(global-set-key (kbd "<Scroll_Lock>") 'scroll-lock-mode)
(global-set-key (kbd "<up>") 'scroll-down-line)
(global-set-key (kbd "<down>") 'scroll-up-line)

(global-set-key (kbd "M-p") 'backward-paragraph)
(global-set-key (kbd "M-n") 'forward-paragraph)

(bind-key* "C-M-w" 'kill-region)

(bind-key* "M-," 'backward-kill-word)
(bind-key* "M-." 'kill-word)

(bind-key* "C-," 'delete-backward-char)
(bind-key* "C-." 'delete-char)

(bind-key* "M-h" 'open-line)

(bind-key* "C-u" 'backward-char)
(bind-key* "C-o" 'forward-char)

(bind-key* "M-u" 'backward-word)
(bind-key* "M-o" 'forward-word)

;;(unbind-key (kbd "C-x"))

;;(bind-key* "C-c" 'kill-ring-save)
;;(bind-key* "C-v" 'yank)
;;(bind-key* "C-x" 'kill-region)

(defun nope ()
(interactive)
(message "NOPE!")
)

;; yo, these keys have better alternatives. Use them!
(bind-key "C-b" 'nope)

(bind-key "M-f" 'nope)
(bind-key "M-b" 'nope)


(bind-key* "C-a" 'nope)

(bind-key* "C-z" 'nope)

(bind-key* "C-a" 'Control-X-prefix)
;;(bind-key* "C-x" 'nope)


;;cua-mode
;;(bind-key "C-w" 'nope)
;;(bind-key "M-C-w" 'nope)
;;(bind-key "C-y" 'nope)

;;(bind-key "<return>" 'Control-X-prefix)

(bind-key* "C-j" 'helm-mini)
;;(bind-key* "M-j" 'other-window)

(bind-key* "C-q" 'beginning-of-line)
(bind-key* "C-w" 'back-to-indentation)

#+end_src

**** Hyper key
#+begin_src emacs-lisp
(global-set-key (kbd "H-M-j") 'next-multiframe-window)
(global-set-key (kbd "H-M-k") 'previous-multiframe-window)
(global-set-key (kbd "H-M-c") 'delete-window)
(global-set-key (kbd "H-j") 'backward-delete-char-untabify)
(global-set-key (kbd "H-k") 'delete-forward-char)

(global-set-key (kbd "H-1") 'delete-other-windows)
(global-set-key (kbd "H-2") 'split-window-below)
(global-set-key (kbd "H-3") 'split-window-right)
(global-set-key (kbd "H-0") 'delete-window)
(global-set-key (kbd "H-e") 'execute-extended-command)

(global-set-key (kbd "H-o") 'other-window)
(global-set-key (kbd "H-f") 'backward-delete-char-untabify)
(global-set-key (kbd "H-j") 'delete-char)

(global-set-key (kbd "H-h") 'backward-kill-word)
(global-set-key (kbd "H-l") 'kill-word)
#+end_src

*** control-semi-map
#+begin_src emacs-lisp
(define-key control-semi-map (kbd "SPC") 'point-to-register)
(define-key control-semi-map (kbd "C-SPC") 'point-to-register)
(define-key control-semi-map (kbd "j") 'jump-to-register)
(define-key control-semi-map (kbd "C-j") 'jump-to-register)
(define-key control-semi-map (kbd "h") 'highlight-phrase)
(define-key control-semi-map (kbd "C-h") 'highlight-phrase)
(define-key control-semi-map (kbd "M-h") 'highlight-phrase)
(define-key control-semi-map (kbd "C-M-h") 'highlight-phrase)
(define-key control-semi-map (kbd "C-w") 'window-configuration-to-register)

(define-key control-semi-map (kbd "q") 'goto-line)
(define-key control-semi-map (kbd "C-q") 'goto-line)

(define-key control-semi-map (kbd "C-l") 'execute-extended-command)

(define-key control-semi-map (kbd "C-1") 'zygospore-toggle-delete-other-windows)
(define-key control-semi-map (kbd "C-2") 'split-window-below)
(define-key control-semi-map (kbd "C-3") 'split-window-right)
(define-key control-semi-map (kbd "C-0") 'delete-window)
(define-key control-semi-map (kbd "C-4") 'balance-windows)

(define-key control-semi-map (kbd "C-f") 'follow-mode)
#+end_src
*** tab map
#+begin_src emacs-lisp
(define-key tab-map (kbd "TAB") 'comment-dwim)
(define-key tab-map (kbd "u") 'universal-argument)

(define-key tab-map (kbd "1") 'avy-goto-char)
(define-key tab-map (kbd "2") 'avy-goto-line)

(define-key tab-map (kbd "p") 'projectile-command-map)
(define-key tab-map (kbd "m") 'magit-command-map)

(define-key tab-map (kbd "f") 'flyspell-mode)
#+end_src
* BEHAVIOUR                                                :config:behaviour:
#+begin_src emacs-lisp
(message "emacs.org : starting behaviour stage")
#+end_src
** cua-mode
#+begin_src emacs-lisp
(cua-mode 1)
(bind-key "C-f" 'cua-exchange-point-and-mark)
#+end_src

** speedbar
#+begin_src emacs-lisp
;; (defconst my-speedbar-buffer-name "SPEEDBAR")
  ;; ; (defconst my-speedbar-buffer-name " SPEEDBAR") ; try this if you get "Wrong type argument: stringp, nil"


  ;; (defun my-speedbar-no-separate-frame ()
  ;;   (interactive)
  ;;   (when (not (buffer-live-p speedbar-buffer))
  ;;     (setq speedbar-buffer (get-buffer-create my-speedbar-buffer-name)
  ;;           speedbar-frame (selected-frame)
  ;;           dframe-attached-frame (selected-frame)
  ;;           speedbar-select-frame-method 'attached
  ;;           speedbar-verbosity-level 0
  ;;           speedbar-last-selected-file nil)
  ;;     (set-buffer speedbar-buffer)
  ;;     (speedbar-mode)
  ;;     (speedbar-reconfigure-keymaps)
  ;;     (speedbar-update-contents)
  ;;     (speedbar-set-timer 1)
  ;;     (make-local-hook 'kill-buffer-hook)
  ;;     (add-hook 'kill-buffer-hook
  ;;               (lambda () (when (eq (current-buffer) speedbar-buffer)
  ;;                            (setq speedbar-frame nil
  ;;                                  dframe-attached-frame nil
  ;;                                  speedbar-buffer nil)
  ;;                            (speedbar-set-timer nil)))))
  ;;   (set-window-buffer (selected-window) 
  ;;                      (get-buffer my-speedbar-buffer-name)))

#+end_src

** gdb
#+begin_src emacs-lisp
;; For the consistency of gdb-select-window's calling convention...
(defun gdb-comint-buffer-name ()
  (buffer-name gud-comint-buffer))
(defun gdb-source-buffer-name ()
  (buffer-name (window-buffer gdb-source-window)))

(defun gdb-select-window (header)
  "Switch directly to the specified GDB window.
Moves the cursor to the requested window, switching between
`gdb-many-windows' \"tabs\" if necessary in order to get there.

Recognized window header names are: 'comint, 'locals, 'registers,
'stack, 'breakpoints, 'threads, and 'source."

  (interactive "Sheader: ")

  (let* ((header-alternate (case header
                             ('locals      'registers)
                             ('registers   'locals)
                             ('breakpoints 'threads)
                             ('threads     'breakpoints)))
         (buffer (intern (concat "gdb-" (symbol-name header) "-buffer")))
         (buffer-names (mapcar (lambda (header)
                                 (funcall (intern (concat "gdb-"
                                                          (symbol-name header)
                                                          "-buffer-name"))))
                               (if (null header-alternate)
                                   (list header)
                                 (list header header-alternate))))
         (window (if (eql header 'source)
                     gdb-source-window
                   (or (get-buffer-window (car buffer-names))
                       (when (not (null (cadr buffer-names)))
                         (get-buffer-window (cadr buffer-names)))))))

    (when (not (null window))
      (let ((was-dedicated (window-dedicated-p window)))
        (select-window window)
        (set-window-dedicated-p window nil)
        (when (member header '(locals registers breakpoints threads))
          (switch-to-buffer (gdb-get-buffer-create buffer))
          (setq header-line-format (gdb-set-header buffer)))
        (set-window-dedicated-p window was-dedicated))
      t)))

;; Use global keybindings for the window selection functions so that they
;; work from the source window too...
;;(mapcar (lambda (setting)
;;          (lexical-let ((key    (car setting))
;;                        (header (cdr setting)))
;;            ;;(global-set-key (concat "\C-c\C-g" key) #'(lambda ()
;;            (global-set-key (concat "\M-;" key) #'(lambda ()
;;                                                                    (interactive)
;;                                                        (gdb-select-window header)))))
;;        '(("c" . comint)
;;          ("l" . locals)
;;          ("r" . registers)
;;          ("u" . source)
;;          ("s" . stack)
;;          ("b" . breakpoints)
;;          ("t" . threads)))

#+end_src

** recentf
#+begin_src emacs-lisp
(require 'recentf)
(recentf-mode 1)
(setq recentf-max-menu-items 500)
#+end_src

** windmove
#+begin_src emacs-lisp
(setq windmove-wrap-around t )
(bind-key* "C-1" 'other-frame)
(bind-key* "C-2" 'windmove-up)
(bind-key* "C-3" 'windmove-right)
#+end_src

** projectile
#+begin_src emacs-lisp
(require 'cl)
(require 'helm)

(projectile-global-mode 1)

(setq projectile-enable-caching t)
;; Custom helm grep
(defun helm-megagrep (targets &optional recurse zgrep exts)
  (let* ((exts (and recurse
                    ;; [FIXME] I could handle this from helm-walk-directory.
                    (not zgrep) ; zgrep doesn't handle -r opt.
                    (not (helm-grep-use-ack-p :where 'recursive))
                    (or exts (helm-grep-get-file-extensions targets))))
         (include-files (and exts
                             (mapconcat #'(lambda (x)
                                            (concat "--include="
                                                    (shell-quote-argument x)))
                                        (if (> (length exts) 1)
                                            (remove "*" exts)
                                          exts) " ")))
         (types (and (not include-files)
                     (not zgrep)
                     recurse
                     ;; When %e format spec is not specified
                     ;; ignore types and do not prompt for choice.
                     (string-match "%e" helm-grep-default-command)
                     (helm-grep-read-ack-type)))
         (follow (and helm-follow-mode-persistent
                      (assoc-default 'follow helm-source-grep))))
    ;; When called as action from an other source e.g *-find-files
    ;; we have to kill action buffer.
    (when (get-buffer helm-action-buffer)
      (kill-buffer helm-action-buffer))
    ;; If `helm-find-files' haven't already started,
    ;; give a default value to `helm-ff-default-directory'.


    ;; We need to store these vars locally
    ;; to pass infos later to `helm-resume'.
    (with-helm-temp-hook 'helm-after-initialize-hook
      (with-helm-buffer
        (set (make-local-variable 'helm-zgrep-recurse-flag)
             (and recurse zgrep))
        ;;(set (make-local-variable 'helm-grep-last-targets) targets)
        (set (make-local-variable 'helm-grep-include-files)
             (or include-files types))
        (set (make-local-variable 'helm-grep-in-recurse) recurse)
        (set (make-local-variable 'helm-grep-use-zgrep) zgrep)

        (set (make-local-variable 'helm-grep-default-command)
             (cond (helm-grep-use-zgrep helm-default-zgrep-command)
                   (helm-grep-in-recurse helm-grep-default-recurse-command)
                   ;; When resuming the local value of
                   ;; `helm-grep-default-command' is used, only git-grep
                   ;; should need this.
                   (t helm-grep-default-command)))))
    ;; Setup the source.
    (setq helm-source-grep
          `((name . ,(if zgrep "Zgrep" (capitalize (if recurse
                                                       (helm-grep-command t)
                                                     (helm-grep-command)))))

            (header-name . (lambda (name)
                             (concat name "(C-c ? Help)")))
            (candidates-process . helm-grep-collect-candidates)
            (filter-one-by-one . helm-grep-filter-one-by-one)
            (candidate-number-limit . 50000)
            (no-matchplugin)
            (nohighlight)
            (mode-line . helm-grep-mode-line-string)
            ;; We need to specify keymap here and as :keymap arg [1]
            ;; to make it available in further resuming.
            (keymap . ,helm-grep-map)
            (history . ,'helm-grep-history)
            (action . ,(delq
                        nil
                        `(("Find File" . helm-grep-action)
                          ("Find file other frame" . helm-grep-other-frame)
                          ,(and (locate-library "elscreen")
                                '("Find file in Elscreen"
                                  . helm-grep-jump-elscreen))
                          ("Save results in grep buffer" . helm-grep-save-results)
                          ("Find file other window" . helm-grep-other-window))))
            (persistent-action . helm-grep-persistent-action)
            (persistent-help . "Jump to line (`C-u' Record in mark ring)")
            (requires-pattern . 2)))
    (and follow (helm-attrset 'follow follow helm-source-grep))
    (helm
     :sources '(helm-source-grep)
     :buffer (format "*project root helm %s*" (helm-grep-command))
     :default-directory default-directory
     :keymap helm-grep-map ; [1]
     :history 'helm-grep-history
     :input  (thing-at-point 'symbol)
     :truncate-lines t)))

(defun hgrep()
  (interactive)
  (helm-megagrep nil
		 '(10)
		 nil
		 '("*.cpp" "*.h" ".c" ".cc" "*.lua" "*.py" "*.pl" "*.xml" "*.el" ".org" ) ;; Only interesting files
		 ))


(defun cpp-root-grep()
  (interactive)
  (helm-megagrep nil
		 '(10)
		 nil
		 '("*.cpp" "*.h" ".c" ".cc" ) ;; Only interesting files
		 ))


;; Prevent issues with the Windows null device (NUL)
;; when using cygwin find with rgrep.
(defadvice grep-compute-defaults (around grep-compute-defaults-advice-null-device)
  "Use cygwin's /dev/null as the null-device."
  (let ((null-device "/dev/null"))
	ad-do-it))
(ad-activate 'grep-compute-defaults)


(defun projectile-helm-grep-root-src ()
  (interactive)
  (projectile-with-default-dir (projectile-project-root)
    (call-interactively 'hgrep )))

(define-key projectile-command-map (kbd "p") 'projectile-helm-grep-root-src)
(define-key projectile-command-map (kbd "j") 'hgrep)
(define-key projectile-command-map (kbd "J") 'cpp-root-grep)


#+end_src
** shell
#+begin_src emacs-lisp
(bind-key* "C-`" 'shell)
#+end_src

** ido
#+begin_src emacs-lisp
(ido-mode 1)
#+end_src

** icomplete+
#+begin_src emacs-lisp
(icomplete-mode 1)
(require 'icomplete+)
#+end_src

** avy
#+begin_src emacs-lisp
(define-key control-semi-map (kbd "C-a") 'avy-goto-line)
#+end_src

** search
#+begin_src emacs-lisp
(eval-after-load "isearch" '(require 'isearch+))
(bind-key "C-s" 'swiper)
#+end_src


** dired+
#+begin_src emacs-lisp
(require 'dired+)
(setq dired-dwim-target t)

(define-key ctl-x-map   "d" 'diredp-dired-files)
(define-key ctl-x-4-map "d" 'diredp-dired-files-other-window)

(define-key dired-mode-map ";" 'diredp-up-directory)

(define-key dired-mode-map "x" 'dired-ranger-move)
(define-key dired-mode-map "c" 'dired-ranger-copy)
(define-key dired-mode-map "v" 'dired-ranger-paste)

(setq dired-listing-switches "-alk")


(defun open-in-external-app ()
  "Open the current file or dired marked files in external app."
  (interactive)
  (let ( doIt
         (myFileList
          (cond
           ((string-equal major-mode "dired-mode") (dired-get-marked-files))
           (t (list (buffer-file-name))) ) ) )

    (setq doIt (if (<= (length myFileList) 5)
                   t
                 (y-or-n-p "Open more than 5 files?") ) )

    (when doIt
      (cond
       ((string-equal system-type "windows-nt")
        (mapc (lambda (fPath) (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)) ) myFileList)
        )
       ((string-equal system-type "darwin")
        (mapc (lambda (fPath) (shell-command (format "open \"%s\"" fPath)) )  myFileList) )
       ((string-equal system-type "gnu/linux")
        (mapc (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath)) ) myFileList) ) ) ) ) )

(global-set-key (kbd "C-<f1>")
		(lambda ()
		  (interactive)
              (find-file "~/")
))

(global-set-key (kbd "C-<f2>")
		(lambda ()
		  (interactive)
		  (find-file "~/mount")))

(global-set-key (kbd "C-<f3>")
		(lambda ()
		  (interactive)
		  (find-file "~/annex")))

(global-set-key (kbd "C-7")
		(lambda ()
		  (interactive)
		  (find-file "~/annex/notes/links.org")))

(global-set-key (kbd "C-8")
		(lambda ()
		  (interactive)
		  (find-file "~/annex/notes/todo.org")))

(global-set-key (kbd "C-9")
		(lambda ()
		  (interactive)
		  (find-file "~/annex/notes/technical-notes.org")))

(global-set-key (kbd "C-0")
		(lambda ()
		  (interactive)
		  (find-file "~/annex/notes/notes.org")))



#+end_src

** Auto complete
#+begin_src emacs-lisp
(require 'auto-complete)
(require 'auto-complete-config)

(define-key control-semi-map (kbd "n") 'auto-complete)
(define-key control-semi-map (kbd "C-n") 'dabbrev-expand)

(global-auto-complete-mode t)
(setq ac-use-quick-help nil)
(setq ac-auto-show-menu nil)

(define-key ac-menu-map "\C-n" 'ac-next)
(define-key ac-menu-map "\C-p" 'ac-previous)

(setq
      ac-auto-show-menu nil
      ac-candidate-limit nil
      ac-delay 20
      ac-disable-facess (quote (font-lock-comment-face font-lock-doc-face))
      ac-ignore-case 'smart
      ac-menu-height 15
      ac-quick-help-delay 1.5
      ac-quick-help-prefer-pos-tip t
      ac-use-quick-help t
)

(defun auto-complete-mode-maybe ()
"AC in all modes"
  (unless (minibufferp (current-buffer))
    (auto-complete-mode 1)))


(require 'ac-dabbrev)
(setq-default ac-sources '(ac-source-dabbrev ac-source-semantic ac-source-semantic-raw))
#+end_src

** ORG mode
#+BEGIN_SRC emacs-lisp
(define-key tab-org-map (kbd "o") 'org-metaright)
(define-key tab-org-map (kbd "u") 'org-metaleft)
(define-key tab-org-map (kbd "p") 'org-metaup)
(define-key tab-org-map (kbd "n") 'org-metadown)

(define-key tab-org-map (kbd "C-o") 'org-shiftright)
(define-key tab-org-map (kbd "C-u") 'org-shiftleft)
(define-key tab-org-map (kbd "C-p") 'org-shiftup)
(define-key tab-org-map (kbd "C-n") 'org-shiftdown)

(define-key tab-org-map (kbd "e") 'org-export-dispatch)


(setq org-src-fontify-natively t)
(setq org-src-preserve-indentation t)
(setq org-startup-indented t)
(setq org-startup-truncated nil)

(setq org-export-with-toc nil)

(setq org-hierarchical-todo-statistics nil)

#+END_SRC
** Misc behaviour
#+begin_src emacs-lisp
(setq column-number-mode 't)

(delete-selection-mode 1)

(delete-selection-mode 1)
(show-paren-mode t)

(setq inhibit-splash-screen t)

(desktop-save-mode t)
(semantic-mode t)
;;(setq indent-tabs-mode nil)
(setq history-length 25)

(winner-mode 1)
(global-set-key (kbd "s-[") 'winner-undo)
(global-set-key (kbd "s-]") 'winner-redo)

(setq backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '(("." . "~/.saves"))    ; don't litter my fs tree
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)       ; use versioned backups

(defun my-create-non-existent-directory ()
      (let ((parent-directory (file-name-directory buffer-file-name)))
        (when (and (not (file-exists-p parent-directory))
                   (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
          (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions #'my-create-non-existent-directory)

#+end_src

** Scrolling behavior
   #+BEGIN_SRC emacs-lisp
   (require 'smooth-scroll)
   (smooth-scroll-mode 1)
   #+END_SRC

** Programming                                :config:behaviour:programming:
*** Generic
#+begin_src emacs-lisp
;;(setq-default tab-width 4)

(setq-default c-basic-offset 4 c-default-style "linux")
(setq-default tab-width 4 indent-tabs-mode t)
;;(define-key c-mode-base-map (kbd "RET") 'newline-and-indent)

#+end_src

*** Haskell
 #+begin_src emacs-lisp
(require 'flymake-haskell-multi)
(add-hook 'haskell-mode-hook
	  (lambda()
	   ;; (haskell-mode 1)
	    (haskell-indent-mode 1)
	    ;;(flymake-haskell-multi-load 1)
	    ))
#+end_src
*** indent modes
#+begin_src emacs-lisp
;;(defun c-lineup-arglist-tabs-only (ignored)
;;  "Line up argument lists by tabs, not spaces"
;;  (let* ((anchor (c-langelem-pos c-syntactic-element))
;;	 (column (c-langelem-2nd-pos c-syntactic-element))
;;	 (offset (- (1+ column) anchor))
;;	 (steps (floor offset c-basic-offset)))
;;    (* (max steps 1)
;;       c-basic-offset)))


;;(add-hook 'c-mode-common-hook
;;          (lambda ()
;;            ;; Add kernel style
;;            (c-add-style
;;             "linux-tabs-only"
;;             '("linux" (c-offsets-alist
;;                        (arglist-cont-nonempty
;;                         c-lineup-gcc-asm-reg
;;                         c-lineup-arglist-tabs-only))))))
#+end_src

*** C
#+begin_src emacs-lisp

(setq
 helm-gtags-ignore-case t
 helm-gtags-auto-update t
 helm-gtags-use-input-at-cursor t
 helm-gtags-pulse-at-cursor t
 helm-gtags-prefix-key "\C-cg"
 helm-gtags-suggested-key-mapping t
 )

;; (require 'helm-gtags)
;; ;; Enable helm-gtags-mode
;; (add-hook 'dired-mode-hook 'helm-gtags-mode)
;; (add-hook 'eshell-mode-hook 'helm-gtags-mode)
;; (add-hook 'c-mode-hook 'helm-gtags-mode)
;; (add-hook 'c++-mode-hook 'helm-gtags-mode)
;; (add-hook 'asm-mode-hook 'helm-gtags-mode)

;; (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
;; (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
;; (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
;; (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
;; (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
;; (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)

(add-hook 'c-mode-hook
          (lambda ()
                ;;(setq indent-tabs-mode t)
                ;;(c-set-style "linux-tabs-only")
)
)

#+end_src

*** C++
#+begin_src emacs-lisp
;;(add-hook 'c++-mode-hook
;;	  (lambda()
;;
;;))

      ;;(setq indent-tabs-mode t)
      ;;(c-set-style "linux-tabs-only"))
#+end_src

*** Python
#+begin_src emacs-lisp

(add-hook 'python-mode-hook
	  (lambda()
		 (setq indent-tabs-mode nil)
		 (setq python-indent 4)
		 (setq tab-width 4)
		 ;;(hs-minor-mode 1)
		 (global-set-key (kbd "H-z") 'hs-toggle-hiding)
		 (global-set-key (kbd "H-x") 'hs-hide-all)
		 (global-set-key (kbd "H-c") 'hs-show-all)
		 ;;(elpy-mode 1)
		 )
	  )
#+end_src

** Mode recognition
#+begin_src emacs-lisp
(autoload 'glsl-mode "glsl-mode" nil t)
(setq auto-mode-alist
      '(
	("\\.org$" . org-mode)
	("\\.org.gpg$" . org-mode)
	("\\.ref$" . org-mode)
	("\\.ref.gpg$" . org-mode)
	("\\.notes$" . org-mode)

	("\\.pdf\\'" . doc-view-mode)

	;;programming modes
	("\\.hs$" . haskell-mode)
	("\\.py\\'" . python-mode)
	("\\.cpp\\'" . c++-mode)
	("\\.h\\'" . c++-mode)
	("\\.lua\\'" . lua-mode)
	("\\.java\\'" . java-mode)

	("\\.s\\'" . c++-mode)
	("\\.mc\\'" . c++-mode)

	("\\.el\\'" . emacs-lisp-mode)

	("\\.vert\\'" . glsl-mode)
	("\\.frag\\'" . glsl-mode)
	("\\.glsl\\'" . glsl-mode)

	("\\.m\\'" . matlab-mode)
	))
#+end_src

** yas
#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(yas-global-mode 1)
#+END_SRC
** Helm
#+begin_src emacs-lisp
(require 'helm-config)
(define-key control-semi-map (kbd "C-s") 'helm-semantic-or-imenu)

(define-key control-semi-map (kbd "l") 'helm-M-x)
(define-key control-semi-map (kbd "o") 'swiper-helm)
(define-key control-semi-map (kbd "C-o") 'helm-multi-occur)

(define-key control-semi-map (kbd "r") 'helm-mark-ring)
(define-key control-semi-map (kbd "C-r") 'helm-all-mark-rings)

(define-key control-semi-map (kbd "b") 'helm-resume)
(define-key control-semi-map (kbd "C-b") 'helm-resume)

(define-key control-semi-map (kbd "C-m") 'helm-swoop)
(define-key control-semi-map (kbd "m") 'helm-multi-swoop-all)

(require 'all-ext) ;; C-c C-a jumps to all from helm-occur
#+end_src
** magit
#+begin_src emacs-lisp
(defvar magit-command-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "m") 'magit-status)
    (define-key map (kbd "s") 'magit-stash)
    (define-key map (kbd "p") 'magit-stash-pop)
    (define-key map (kbd "l") 'magit-log)
    map))
(fset 'magit-command-map magit-command-map)
#+end_src

** custom
#+begin_src emacs-lisp
(defun reload-emacs-config ()
(interactive)
(interactive)
(load-file "~/.emacs"))

(defun destruct-emacs-config ()
(interactive)
(delete-file "~/.emacs.d/emacs.org"))

(defun get-repo-config()
(interactive)
(destruct-emacs-config)
(reload-emacs-config))

(defun igf-clean()
(interactive)
(flush-lines "No such file or directory")
(flush-lines "Is a directory")
(flush-lines ".svn-base")
)

(defun org-babel-reload-emacs-org()
(interactive)
(org-babel-load-file "~/.emacs.d/emacs.org")
)

#+end_src

** 
* LOOKS                                                       :config::looks:
#+begin_src emacs-lisp
(message "emacs.org : starting looks stage")
#+end_src
** themes and colours
#+begin_src emacs-lisp
(global-highline-mode 1)
(blink-cursor-mode -1)
;;(set-cursor-color "BlueViolet")
(set-cursor-color "DarkOrange1")
#+END_SRC
** Buffer names
   Setup uniquify so that non-unique buffer names get the parent path
   included to make them unique.!!!!
   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (require 'uniquify)
     (setq uniquify-buffer-name-style 'forward)
   #+END_SRC
** Mode line
#+NAME: look-and-feel
#+BEGIN_SRC emacs-lisp

;;(require 'powerline)
;; (set-face-attribute 'mode-line nil
;;                    :foreground "grey90"
;;                    :background "SaddleBrown"
;;                    :box nil)

;; (set-face-attribute 'mode-line-inactive nil
;;                    :box nil)

;; (setq powerline-arrow-shape 'arrow14)
;; (powerline-default-theme)
;;
;;;; Workaroung to prevent desktop save from messing up powerline colours
;;(defadvice desktop-kill(before clear-power-line-cache () activate)
;;   (set-frame-parameter nil 'powerline-cache nil))

;;(setq powerline-arrow-shape 'arrow14)
;;(powerline-default-theme)

;;(defadvice desktop-kill(before clear-power-line-cache () activate)
;;  (set-frame-parameter nil 'powerline-cache nil))
#+END_SRC
** auto highlight symbol
#+begin_src emacs-lisp
(global-auto-highlight-symbol-mode 1)
#+end_src

* ALIAS                                                        :config:alias:
#+begin_src emacs-lisp
(message "emacs.org : starting alias stage")
#+end_src
#+begin_src emacs-lisp

;;Too lazy for this
(defalias 'yes-or-no-p 'y-or-n-p)

(defalias 'describe-bindings 'helm-descbinds)

(defalias 'rel 'reload-emacs-config)
(defalias 'lp 'list-packages)
(defalias 'igf 'igrep-find)
(defalias 'msf 'menu-set-font)
(defalias 'obr 'org-babel-reload-emacs-org)


(require 'hydra)
(defhydra hydra-zoom (global-map "<f2>")
  "zoom"
  ("g" text-scale-increase "in")
  ("l" text-scale-decrease "out"))

(require 'hydra)
(defhydra hydra-split (global-map "<f3>")
"hydrasplit"
  ("h" hydra-move-splitter-left)
    ("j" hydra-move-splitter-down)
    ("k" hydra-move-splitter-up)
    ("l" hydra-move-splitter-right))

(message "emacs.org : done loading!")
#+end_src
