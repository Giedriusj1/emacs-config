#+TITLE: Emacs config

* INIT BASICS                                                 :config:basics:
** repo load
#+begin_src emacs-lisp
(require 'package)
(require 'cl)

(add-to-list 'load-path "~/.emacs.d/elpa")
(setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
			 ("malade" . "http://marmalade-repo.org/packages/")
			 ("melpa" . "http://melpa.milkbox.net/packages/")))

(package-initialize)

(setq url-http-attempt-keepalives nil)

(defvar package-list
  '(yasnippet
    igrep
    zygospore
    bookmark+
    helm-descbinds
    auto-highlight-symbol
    helm-projectile
    helm-projectile-all
    dired-toggle-sudo
    multi-term
    iasm-mode
    haskell-mode
    magit
    highline
    lua-mode
    smooth-scrolling
    auctex
    emacs-eclim
    ace-jump-mode
    auto-install
    auto-complete-clang
    helm
    helm-swoop
    bind-key
    projectile
    auto-complete-c-headers
    powerline
    icomplete+
    ace-jump-mode
    dired+
    dired-ranger
    auto-complete
    ac-dabbrev
    isearch+
    smooth-scroll
    flymake-haskell-multi
    all-ext)
)

(defun packages-installed ()
  (loop for p in package-list
        when (not (package-installed-p p)) do (return nil)
        finally (return t)))

(unless (packages-installed)
  (package-refresh-contents)

  (dolist (p package-list)
    (when (not (package-installed-p p))
      (package-install p))))

#+end_src

** Keyboard
*** maps
#+begin_src emacs-lisp
(define-prefix-command 'alt-semi-map)
(define-prefix-command 'control-semi-map)
(define-prefix-command 'tab-map)
(define-prefix-command 'ret-map)
(define-prefix-command 'hyper-semi-map)
(define-prefix-command 'meta-semi-map)

(require 'bind-key)
(bind-key* "C-;" 'control-semi-map)
(bind-key* "H-;" 'hyper-semi-map)
(bind-key* "M-;" 'meta-semi-map)
(bind-key* "<tab>" 'tab-map)

(global-set-key (kbd "C-d") 'delete-backward-char)
#+end_src

*** global map
#+begin_src emacs-lisp
(global-set-key [f11] 'toggle-truncate-lines)
(global-set-key [f12] 'whitespace-mode)

(global-set-key (kbd "<Scroll_Lock>") 'scroll-lock-mode)
(global-set-key (kbd "<up>") 'scroll-down-line)
(global-set-key (kbd "<down>") 'scroll-up-line)

(global-set-key (kbd "M-p") 'backward-paragraph)
(global-set-key (kbd "M-n") 'forward-paragraph)

(bind-key* "C-M-w" 'kill-region)

(bind-key* "M-," 'backward-kill-word)
(bind-key* "M-." 'kill-word)

(bind-key* "C-," 'delete-backward-char)
(bind-key* "C-." 'delete-char)

(bind-key* "M-h" 'open-line)

(bind-key* "C-u" 'backward-char)
(bind-key* "C-o" 'forward-char)

(bind-key* "M-u" 'backward-word)
(bind-key* "M-o" 'forward-word)

(defun nope ()
(interactive)
(message "NOPE!")
)

;; yo, these keys have better alternatives. Use them!
;;(bind-key "C-f" 'nope)
(bind-key "C-b" 'nope)

(bind-key "M-f" 'nope)
(bind-key "M-b" 'nope)

(bind-key "M-b" 'nope)

(bind-key* "C-a" 'nope)

(bind-key "DEL" 'nope)

(bind-key* "C-z" 'nope)

(bind-key* "C-a" 'Control-X-prefix)
;;(bind-key* "C-x" 'nope)

;;(bind-key "<return>" 'Control-X-prefix)

(bind-key* "C-j" 'helm-mini)
;;(bind-key* "M-j" 'other-window)

(bind-key* "C-q" 'beginning-of-line)
(bind-key* "C-w" 'back-to-indentation)

#+end_src

**** Hyper key
#+begin_src emacs-lisp
(global-set-key (kbd "H-M-j") 'next-multiframe-window)
(global-set-key (kbd "H-M-k") 'previous-multiframe-window)
(global-set-key (kbd "H-M-c") 'delete-window)
(global-set-key (kbd "H-j") 'backward-delete-char-untabify)
(global-set-key (kbd "H-k") 'delete-forward-char)

(global-set-key (kbd "H-1") 'delete-other-windows)
(global-set-key (kbd "H-2") 'split-window-below)
(global-set-key (kbd "H-3") 'split-window-right)
(global-set-key (kbd "H-0") 'delete-window)
(global-set-key (kbd "H-e") 'execute-extended-command)

(global-set-key (kbd "H-o") 'other-window)
(global-set-key (kbd "H-f") 'backward-delete-char-untabify)
(global-set-key (kbd "H-j") 'delete-char)

(global-set-key (kbd "H-h") 'backward-kill-word)
(global-set-key (kbd "H-l") 'kill-word)
#+end_src

*** control-semi-map
#+begin_src emacs-lisp
(define-key control-semi-map (kbd "SPC") 'point-to-register)
(define-key control-semi-map (kbd "C-SPC") 'point-to-register)
(define-key control-semi-map (kbd "j") 'jump-to-register)
(define-key control-semi-map (kbd "C-j") 'jump-to-register)
(define-key control-semi-map (kbd "h") 'highlight-phrase)
(define-key control-semi-map (kbd "C-h") 'highlight-phrase)
(define-key control-semi-map (kbd "M-h") 'highlight-phrase)
(define-key control-semi-map (kbd "C-M-h") 'highlight-phrase)
(define-key control-semi-map (kbd "C-w") 'window-configuration-to-register)

(define-key control-semi-map (kbd "q") 'goto-line)
(define-key control-semi-map (kbd "C-q") 'goto-line)

(define-key control-semi-map (kbd "C-l") 'execute-extended-command)

(define-key control-semi-map (kbd "C-1") 'zygospore-toggle-delete-other-windows)
(define-key control-semi-map (kbd "C-2") 'split-window-below)
(define-key control-semi-map (kbd "C-3") 'split-window-right)
(define-key control-semi-map (kbd "C-0") 'delete-window)
(define-key control-semi-map (kbd "C-4") 'balance-windows)

(define-key control-semi-map (kbd "C-f") 'follow-mode)
#+end_src
*** tab map
#+begin_src emacs-lisp
(define-key tab-map (kbd "TAB") 'comment-dwim)
(define-key tab-map (kbd "u") 'universal-argument)

(define-key tab-map (kbd "1") 'ace-jump-char-mode)
(define-key tab-map (kbd "2") 'ace-jump-line-mode)

(define-key tab-map (kbd "p") 'projectile-command-map)
(define-key tab-map (kbd "m") 'magit-command-map)

(define-key tab-map (kbd "f") 'flyspell-mode)
#+end_src

* LOOKS                                                       :config::looks:
** themes and colours
#+BEGIN_SRC emacs-lisp
(cond
 ((string-equal system-type "windows-nt")
  (set-frame-font "Consolas-10"))
 ((string-equal system-type "darwin")
  (message "what?"))
 ((string-equal system-type "gnu/linux")
  (set-frame-font "Monospace-10"))
)

(custom-set-variables
 '(bmkp-last-as-first-bookmark-file "~/.emacs.d/bookmarks")
 '(custom-enabled-themes (quote (wombat)))
 '(directory-free-space-args "-Pkh")
 '(electric-pair-mode t)
 '(fci-rule-color "#BBBBBB")
 '(menu-bar-mode nil)
 '(scroll-bar-mode nil)
 '(send-mail-function (quote sendmail-send-it))
 '(tool-bar-mode nil)
 (custom-set-faces
 '(highline-face ((t (:background "#303030")))))
 )

(global-highline-mode 1)
(blink-cursor-mode -1)
(set-cursor-color "BlueViolet")
#+END_SRC

** Buffer names
   Setup uniquify so that non-unique buffer names get the parent path
   included to make them unique.!!!!
   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (require 'uniquify)
     (setq uniquify-buffer-name-style 'forward)
   #+END_SRC
** Mode line
#+NAME: look-and-feel
#+BEGIN_SRC emacs-lisp
(require 'powerline)
(set-face-attribute 'mode-line nil
                    :foreground "grey90"
                    :background "SaddleBrown"
                    :box nil)

(set-face-attribute 'mode-line-inactive nil
                    :box nil)

(setq powerline-arrow-shape 'arrow14)
(powerline-default-theme)

(defadvice desktop-kill(before clear-power-line-cache () activate)
  (set-frame-parameter nil 'powerline-cache nil))
#+END_SRC
** auto highlight symbol
#+begin_src emacs-lisp
(global-auto-highlight-symbol-mode 1)

#+end_src

* BEHAVIOUR                                                :config:behaviour:
** speedbar
#+begin_src emacs-lisp
  (defconst my-speedbar-buffer-name "SPEEDBAR")
  ; (defconst my-speedbar-buffer-name " SPEEDBAR") ; try this if you get "Wrong type argument: stringp, nil"


  (defun my-speedbar-no-separate-frame ()
    (interactive)
    (when (not (buffer-live-p speedbar-buffer))
      (setq speedbar-buffer (get-buffer-create my-speedbar-buffer-name)
            speedbar-frame (selected-frame)
            dframe-attached-frame (selected-frame)
            speedbar-select-frame-method 'attached
            speedbar-verbosity-level 0
            speedbar-last-selected-file nil)
      (set-buffer speedbar-buffer)
      (speedbar-mode)
      (speedbar-reconfigure-keymaps)
      (speedbar-update-contents)
      (speedbar-set-timer 1)
      (make-local-hook 'kill-buffer-hook)
      (add-hook 'kill-buffer-hook
                (lambda () (when (eq (current-buffer) speedbar-buffer)
                             (setq speedbar-frame nil
                                   dframe-attached-frame nil
                                   speedbar-buffer nil)
                             (speedbar-set-timer nil)))))
    (set-window-buffer (selected-window) 
                       (get-buffer my-speedbar-buffer-name)))

#+end_src

** gdb
#+begin_src emacs-lisp
;; For the consistency of gdb-select-window's calling convention...
(defun gdb-comint-buffer-name ()
  (buffer-name gud-comint-buffer))
(defun gdb-source-buffer-name ()
  (buffer-name (window-buffer gdb-source-window)))

(defun gdb-select-window (header)
  "Switch directly to the specified GDB window.
Moves the cursor to the requested window, switching between
`gdb-many-windows' \"tabs\" if necessary in order to get there.

Recognized window header names are: 'comint, 'locals, 'registers,
'stack, 'breakpoints, 'threads, and 'source."

  (interactive "Sheader: ")

  (let* ((header-alternate (case header
                             ('locals      'registers)
                             ('registers   'locals)
                             ('breakpoints 'threads)
                             ('threads     'breakpoints)))
         (buffer (intern (concat "gdb-" (symbol-name header) "-buffer")))
         (buffer-names (mapcar (lambda (header)
                                 (funcall (intern (concat "gdb-"
                                                          (symbol-name header)
                                                          "-buffer-name"))))
                               (if (null header-alternate)
                                   (list header)
                                 (list header header-alternate))))
         (window (if (eql header 'source)
                     gdb-source-window
                   (or (get-buffer-window (car buffer-names))
                       (when (not (null (cadr buffer-names)))
                         (get-buffer-window (cadr buffer-names)))))))

    (when (not (null window))
      (let ((was-dedicated (window-dedicated-p window)))
        (select-window window)
        (set-window-dedicated-p window nil)
        (when (member header '(locals registers breakpoints threads))
          (switch-to-buffer (gdb-get-buffer-create buffer))
          (setq header-line-format (gdb-set-header buffer)))
        (set-window-dedicated-p window was-dedicated))
      t)))

;; Use global keybindings for the window selection functions so that they
;; work from the source window too...
(mapcar (lambda (setting)
          (lexical-let ((key    (car setting))
                        (header (cdr setting)))
            ;;(global-set-key (concat "\C-c\C-g" key) #'(lambda ()
            (global-set-key (concat "\M-;" key) #'(lambda ()
                                                                    (interactive)
                                                        (gdb-select-window header)))))
        '(("c" . comint)
          ("l" . locals)
          ("r" . registers)
          ("u" . source)
          ("s" . stack)
          ("b" . breakpoints)
          ("t" . threads)))

#+end_src

** recentf
#+begin_src emacs-lisp
(require 'recentf)
(recentf-mode 1)
(setq recentf-max-menu-items 500)
#+end_src

** windmove
#+begin_src emacs-lisp
(setq windmove-wrap-around t )
(bind-key* "C-1" 'other-frame)
(bind-key* "C-2" 'windmove-up)
(bind-key* "C-3" 'windmove-right)
#+end_src

** projectile
#+begin_src emacs-lisp
(require 'cl)
(require 'helm)
(projectile-global-mode 1)

;; Custom helm grep
(defun helm-megagrep (targets &optional recurse zgrep exts)
  (let* ((exts (and recurse
                    ;; [FIXME] I could handle this from helm-walk-directory.
                    (not zgrep) ; zgrep doesn't handle -r opt.
                    (not (helm-grep-use-ack-p :where 'recursive))
                    (or exts (helm-grep-get-file-extensions targets))))
         (include-files (and exts
                             (mapconcat #'(lambda (x)
                                            (concat "--include="
                                                    (shell-quote-argument x)))
                                        (if (> (length exts) 1)
                                            (remove "*" exts)
                                          exts) " ")))
         (types (and (not include-files)
                     (not zgrep)
                     recurse
                     ;; When %e format spec is not specified
                     ;; ignore types and do not prompt for choice.
                     (string-match "%e" helm-grep-default-command)
                     (helm-grep-read-ack-type)))
         (follow (and helm-follow-mode-persistent
                      (assoc-default 'follow helm-source-grep))))
    ;; When called as action from an other source e.g *-find-files
    ;; we have to kill action buffer.
    (when (get-buffer helm-action-buffer)
      (kill-buffer helm-action-buffer))
    ;; If `helm-find-files' haven't already started,
    ;; give a default value to `helm-ff-default-directory'.


    ;; We need to store these vars locally
    ;; to pass infos later to `helm-resume'.
    (with-helm-temp-hook 'helm-after-initialize-hook
      (with-helm-buffer
        (set (make-local-variable 'helm-zgrep-recurse-flag)
             (and recurse zgrep))
        ;;(set (make-local-variable 'helm-grep-last-targets) targets)
        (set (make-local-variable 'helm-grep-include-files)
             (or include-files types))
        (set (make-local-variable 'helm-grep-in-recurse) recurse)
        (set (make-local-variable 'helm-grep-use-zgrep) zgrep)

        (set (make-local-variable 'helm-grep-default-command)
             (cond (helm-grep-use-zgrep helm-default-zgrep-command)
                   (helm-grep-in-recurse helm-grep-default-recurse-command)
                   ;; When resuming the local value of
                   ;; `helm-grep-default-command' is used, only git-grep
                   ;; should need this.
                   (t helm-grep-default-command)))))
    ;; Setup the source.
    (setq helm-source-grep
          `((name . ,(if zgrep "Zgrep" (capitalize (if recurse
                                                       (helm-grep-command t)
                                                     (helm-grep-command)))))

            (header-name . (lambda (name)
                             (concat name "(C-c ? Help)")))
            (candidates-process . helm-grep-collect-candidates)
            (filter-one-by-one . helm-grep-filter-one-by-one)
            (candidate-number-limit . 50000)
            (no-matchplugin)
            (nohighlight)
            (mode-line . helm-grep-mode-line-string)
            ;; We need to specify keymap here and as :keymap arg [1]
            ;; to make it available in further resuming.
            (keymap . ,helm-grep-map)
            (history . ,'helm-grep-history)
            (action . ,(delq
                        nil
                        `(("Find File" . helm-grep-action)
                          ("Find file other frame" . helm-grep-other-frame)
                          ,(and (locate-library "elscreen")
                                '("Find file in Elscreen"
                                  . helm-grep-jump-elscreen))
                          ("Save results in grep buffer" . helm-grep-save-results)
                          ("Find file other window" . helm-grep-other-window))))
            (persistent-action . helm-grep-persistent-action)
            (persistent-help . "Jump to line (`C-u' Record in mark ring)")
            (requires-pattern . 2)))
    (and follow (helm-attrset 'follow follow helm-source-grep))
    (helm
     :sources '(helm-source-grep)
     :buffer (format "*project root helm %s*" (helm-grep-command))
     :default-directory default-directory
     :keymap helm-grep-map ; [1]
     :history 'helm-grep-history
     :input  (thing-at-point 'symbol)
     :truncate-lines t)))

(defun hgrep()
  (interactive)
  (helm-megagrep nil
		 '(10)
		 nil
		 '("*.cpp" "*.h" "*.lua" "*.py" "*.pl" "*.xml" "*.el" ".org" ) ;; Only interesting files
		 ))

(defun projectile-helm-grep-root-src ()
  (interactive)
  (projectile-with-default-dir (projectile-project-root)
    (call-interactively 'hgrep )))

(define-key projectile-command-map (kbd "p") 'projectile-helm-grep-root-src)

#+end_src
** shell
#+begin_src emacs-lisp
(bind-key* "C-`" 'shell)
#+end_src

** ido
#+begin_src emacs-lisp
(ido-mode 1)
#+end_src

** icomplete+
#+begin_src emacs-lisp
(icomplete-mode 1)
(require 'icomplete+)
#+end_src

** ace-jump
#+begin_src emacs-lisp
(require 'ace-jump-mode)
(global-set-key (kbd "M-SPC") 'ace-jump-mode)
#+end_src

** dired+
#+begin_src emacs-lisp
(require 'dired+)
(setq dired-dwim-target t)

(define-key ctl-x-map   "d" 'diredp-dired-files)
(define-key ctl-x-4-map "d" 'diredp-dired-files-other-window)

(setq dired-listing-switches "-alk")


(defun open-in-external-app ()
  "Open the current file or dired marked files in external app."
  (interactive)
  (let ( doIt
         (myFileList
          (cond
           ((string-equal major-mode "dired-mode") (dired-get-marked-files))
           (t (list (buffer-file-name))) ) ) )

    (setq doIt (if (<= (length myFileList) 5)
                   t
                 (y-or-n-p "Open more than 5 files?") ) )

    (when doIt
      (cond
       ((string-equal system-type "windows-nt")
        (mapc (lambda (fPath) (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)) ) myFileList)
        )
       ((string-equal system-type "darwin")
        (mapc (lambda (fPath) (shell-command (format "open \"%s\"" fPath)) )  myFileList) )
       ((string-equal system-type "gnu/linux")
        (mapc (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath)) ) myFileList) ) ) ) ) )

;; quick access to home dir
(global-set-key (kbd "S-<f1>") ;;Shift-f1 opens dired home folder
		(lambda ()
		  (interactive)
		  (diredp-dired-files "~/")))
#+end_src

** Auto complete
#+begin_src emacs-lisp
(require 'auto-complete)
(require 'auto-complete-config)

(define-key control-semi-map (kbd "n") 'auto-complete)
(define-key control-semi-map (kbd "C-n") 'dabbrev-expand)

(global-auto-complete-mode t)
(setq ac-use-quick-help nil)
(setq ac-auto-show-menu nil)

(define-key ac-menu-map "\C-n" 'ac-next)
(define-key ac-menu-map "\C-p" 'ac-previous)

(setq
      ac-auto-show-menu nil
      ac-candidate-limit nil
      ac-delay 20
      ac-disable-faces (quote (font-lock-comment-face font-lock-doc-face))
      ac-ignore-case 'smart
      ac-menu-height 15
      ac-quick-help-delay 1.5
      ac-quick-help-prefer-pos-tip t
      ac-use-quick-help t
)

(defun auto-complete-mode-maybe ()
"AC in all modes"
  (unless (minibufferp (current-buffer))
    (auto-complete-mode 1)))


(require 'ac-dabbrev)
(setq-default ac-sources '(ac-source-dabbrev ac-source-semantic ac-source-semantic-raw))
#+end_src

** ORG mode
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
(setq org-src-preserve-indentation t)
(setq org-startup-indented t)
(setq org-startup-truncated nil)

(setq org-export-with-toc nil)
(define-key control-semi-map (kbd "M-e") 'org-export)
#+END_SRC
** Misc behaviour
#+begin_src emacs-lisp
(setq column-number-mode 't)

(delete-selection-mode 1)

(delete-selection-mode 1)
(show-paren-mode t)

(setq inhibit-splash-screen t)

(desktop-save-mode t)
(semantic-mode t)
(setq indent-tabs-mode nil)
(setq history-length 25)

(eval-after-load "isearch" '(require 'isearch+))

(winner-mode 1)
(global-set-key (kbd "s-[") 'winner-undo)
(global-set-key (kbd "s-]") 'winner-redo)

(setq backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '(("." . "~/.saves"))    ; don't litter my fs tree
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)       ; use versioned backups
#+end_src

** Scrolling behavior
   #+BEGIN_SRC emacs-lisp
   (require 'smooth-scroll)
   (smooth-scroll-mode 1)
   #+END_SRC

** Programming                                :config:behaviour:programming:
*** Haskell
 #+begin_src emacs-lisp
(require 'flymake-haskell-multi)
(add-hook 'haskell-mode-hook
	  (lambda()
	   ;; (haskell-mode 1)
	    (haskell-indent-mode 1)
	    ;;(flymake-haskell-multi-load 1)
	    ))
#+end_src
*** C
#+begin_src emacs-lisp
(add-hook 'c-mode-common-hook
	  (lambda()
	    (hs-minor-mode 1)
	    (cwarn-mode t)
      ;;(flyspell-prog-mode t)
	    ))
#+end_src
*** COMMENT C++
#+begin_src emacs-lisp
(add-hook 'c++-mode-common-hook
	  (lambda()
	    (hs-minor-mode 1)
	    (cwarn-mode t)
      ;;(flyspell-prog-mode t)
	    ))
#+end_src

*** Python
#+begin_src emacs-lisp

(add-hook 'python-mode-hook
	  (lambda()
		 (setq indent-tabs-mode t)
		 (setq python-indednt 8)
		 (setq tab-width 4)
		 (hs-minor-mode 1)
		 (global-set-key (kbd "H-z") 'hs-toggle-hiding)
		 (global-set-key (kbd "H-x") 'hs-hide-all)
		 (global-set-key (kbd "H-c") 'hs-show-all)
		 )
	  )
#+end_src

** Mode recognition
#+begin_src emacs-lisp
(autoload 'glsl-mode "glsl-mode" nil t)
(setq auto-mode-alist
      '(
	("\\.org$" . org-mode)
	("\\.org.gpg$" . org-mode)
	("\\.ref$" . org-mode)
	("\\.ref.gpg$" . org-mode)
	("\\.notes$" . org-mode)

	("\\.pdf\\'" . doc-view-mode)

	;;programming modes
	("\\.hs$" . haskell-mode)
	("\\.py\\'" . python-mode)
	("\\.cpp\\'" . c++-mode)
	("\\.h\\'" . c++-mode)
	("\\.lua\\'" . lua-mode)

	("\\.s\\'" . c++-mode)
	("\\.mc\\'" . c++-mode)

	("\\.el\\'" . emacs-lisp-mode)

	("\\.vert\\'" . glsl-mode)
	("\\.frag\\'" . glsl-mode)
	("\\.glsl\\'" . glsl-mode)
	))
#+end_src

** yas
#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(yas-global-mode 1)
#+END_SRC
** Helm
#+begin_src emacs-lisp
(require 'helm-config)
(define-key control-semi-map (kbd "C-s") 'helm-semantic-or-imenu)

(define-key control-semi-map (kbd "l") 'helm-M-x)
(define-key control-semi-map (kbd "o") 'helm-occur)
(define-key control-semi-map (kbd "C-o") 'helm-multi-occur)

(define-key control-semi-map (kbd "r") 'helm-mark-ring)
(define-key control-semi-map (kbd "C-r") 'helm-all-mark-rings)

(define-key control-semi-map (kbd "b") 'helm-resume)
(define-key control-semi-map (kbd "C-b") 'helm-resume)

(define-key control-semi-map (kbd "C-m") 'helm-swoop)
(define-key control-semi-map (kbd "m") 'helm-multi-swoop-all)

(require 'all-ext) ;; C-c C-a jumps to all from helm-occur
#+end_src
** magit
#+begin_src emacs-lisp
(defvar magit-command-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "m") 'magit-status)
    (define-key map (kbd "s") 'magit-stash)
    (define-key map (kbd "p") 'magit-stash-pop)
    (define-key map (kbd "l") 'magit-log)
    map))
(fset 'magit-command-map magit-command-map)
#+end_src

** custom
#+begin_src emacs-lisp
(defun reload-emacs-config ()
(interactive)
(load-file "~/.emacs"))

(defun destruct-emacs-config ()
(interactive)
(delete-file "~/.emacs.d/emacs.org"))

(defun get-repo-config()
(interactive)
(destruct-emacs-config)
(reload-emacs-config))
#+end_src

* ALIAS                                                        :config:alias:
#+begin_src emacs-lisp

;;Too lazy for this
(defalias 'yes-or-no-p 'y-or-n-p)

(defalias 'describe-bindings 'helm-descbinds)

(defalias 'rel 'reload-emacs-config)
(defalias 'lp 'list-packages)
(defalias 'igf 'igrep-find)
(defalias 'msf 'menu-set-font)
#+end_src
